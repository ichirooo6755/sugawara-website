<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hand-Controlled 3D Particles + Model Exploder</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    html,
    body {
      height: 100%;
      background: #0b0f14;
    }

    canvas {
      display: block;
    }

    .panel-blur {
      backdrop-filter: blur(10px);
    }
  </style>
</head>

<body class="text-white">
  <!-- UI Panel -->
  <div class="fixed top-4 left-1/2 -translate-x-1/2 z-50">
    <div
      class="panel-blur bg-white/10 rounded-2xl shadow-lg border border-white/10 p-3 sm:p-4 flex flex-wrap items-center gap-3 sm:gap-4">
      <div class="flex items-center gap-2">
        <span class="text-xs sm:text-sm text-white/70">Template</span>
        <select id="templateSelect"
          class="appearance-none bg-white/10 hover:bg-white/20 transition-colors rounded-xl px-3 py-2 text-sm outline-none border border-white/10">
          <option value="hearts">Hearts</option>
          <option value="flowers">Flowers</option>
          <option value="saturn">Saturn</option>
          <option value="fireworks">Fireworks</option>
        </select>
      </div>

      <div class="flex items-center gap-2">
        <span class="text-xs sm:text-sm text-white/70">Mode</span>
        <select id="modeSelect"
          class="appearance-none bg-white/10 hover:bg-white/20 transition-colors rounded-xl px-3 py-2 text-sm outline-none border border-white/10">
          <option value="particles">Particles</option>
          <option value="model" selected>Model</option>
        </select>
      </div>

      <div id="modelControls" class="flex items-center gap-2 hidden">
        <label class="text-xs sm:text-sm text-white/70" for="modelFile">GLTF/GLB</label>
        <input id="modelFile" type="file" accept=".glb,.gltf"
          class="text-xs sm:text-sm file:mr-2 file:rounded-lg file:border file:border-white/10 file:bg-white/10 file:px-3 file:py-1.5 file:text-white file:hover:bg-white/20 file:cursor-pointer" />
      </div>

      <div class="flex items-center gap-2">
        <span class="text-xs sm:text-sm text-white/70">Color</span>
        <input id="colorPicker" type="color" value="#ff6ad5"
          class="w-10 h-10 p-1 rounded-xl bg-transparent border border-white/10" />
      </div>
      <div class="hidden sm:flex items-center gap-2">
        <label class="text-xs sm:text-sm text-white/70" for="debugToggle">Debug</label>
        <input id="debugToggle" type="checkbox" class="w-4 h-4" />
      </div>
    </div>
  </div>

  <!-- Status / Hints -->
  <div id="status"
    class="fixed bottom-4 left-1/2 -translate-x-1/2 z-50 panel-blur bg-white/5 rounded-full px-4 py-2 text-xs sm:text-sm text-white/70 border border-white/10">
    Initializing camera and models…
  </div>

  <!-- 3D container -->
  <div id="app" class="w-screen h-screen"></div>

  <!-- Hidden camera elements -->
  <video id="input-video" playsinline class="hidden"></video>
  <canvas id="debug-canvas"
    class="hidden fixed right-4 top-20 w-64 h-36 rounded-xl border border-cyan-500/30 shadow-lg"></canvas>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <!-- Import map for modern Three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    // Basic selectors
    const appEl = document.getElementById('app');
    const statusEl = document.getElementById('status-text') || document.getElementById('status');
    const videoEl = document.getElementById('input-video');
    const debugCanvas = document.getElementById('debug-canvas');
    const templateSelect = document.getElementById('templateSelect');
    const colorPicker = document.getElementById('colorPicker');
    const debugToggle = document.getElementById('debugToggle');
    const modeSelect = document.getElementById('modeSelect');
    const modelControls = document.getElementById('modelControls');
    const modelFileInput = document.getElementById('modelFile');

    // THREE.js setup
    let renderer, scene, camera, particlePoints, particleGroup;
    let geometry, material, positions, velocities, life, colors;
    const PARTICLE_COUNT = 3000;
    const targetShapes = { hearts: [], flowers: [], saturn: [] };
    let currentTemplate = 'hearts';
    let activeMode = 'model'; // Default to Model mode

    // Model mode state
    let modelGroup;
    let modelParts = []; // { obj, base: Vector3, dir: Vector3 }
    let modelRadius = 1; // bounding sphere radius before normalization
    let modelNormScale = 1; // scales model to ~unit radius

    // Gesture state
    let haveHands = 0;
    let lastIndexTip = null; // last index tip of primary hand in normalized coords
    let rotationVel = { x: 0, y: 0, z: 0 };
    const ROT_DAMP = 0.9;
    let globalScale = 1.2; // controlled by distance between both index tips
    let expansion = 0.2;   // controlled by hand openness

    // Fireworks specific
    let fwCooldown = 0;

    // Debug
    let drawCtx = debugCanvas.getContext('2d');

    // Utils
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const lerp = (a, b, t) => a + (b - a) * t;

    function makeCircleTexture(size = 128) {
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const g = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      g.addColorStop(0, 'rgba(255,255,255,1)');
      g.addColorStop(0.3, 'rgba(255,255,255,0.9)');
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, size, size);
      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = false;
      return tex;
    }

    function initThree() {
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(appEl.clientWidth, appEl.clientHeight);
      renderer.physicallyCorrectLights = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      appEl.appendChild(renderer.domElement);

      // ===== PREMIUM SHOWROOM ENVIRONMENT =====
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050508);
      scene.fog = new THREE.FogExp2(0x050508, 0.08);

      camera = new THREE.PerspectiveCamera(50, appEl.clientWidth / appEl.clientHeight, 0.1, 100);
      camera.position.set(0, 1.2, 5);
      camera.lookAt(0, 0, 0);

      // Ambient (very subtle)
      const ambient = new THREE.HemisphereLight(0x0a1628, 0x080808, 0.3);
      scene.add(ambient);

      // Key Light (Front-Top, warm)
      const keyLight = new THREE.SpotLight(0xffeedd, 80);
      keyLight.position.set(3, 6, 4);
      keyLight.angle = 0.4;
      keyLight.penumbra = 0.8;
      keyLight.decay = 2;
      keyLight.castShadow = true;
      scene.add(keyLight);
      scene.add(keyLight.target);

      // Rim Light (Back-Left, Cyan)
      const rimLight1 = new THREE.SpotLight(0x00ffff, 60);
      rimLight1.position.set(-4, 3, -3);
      rimLight1.angle = 0.5;
      rimLight1.penumbra = 1;
      rimLight1.decay = 2;
      scene.add(rimLight1);

      // Rim Light (Back-Right, Magenta)
      const rimLight2 = new THREE.SpotLight(0xff00ff, 40);
      rimLight2.position.set(4, 2, -4);
      rimLight2.angle = 0.6;
      rimLight2.penumbra = 1;
      rimLight2.decay = 2;
      scene.add(rimLight2);

      // Fill Light (Bottom, subtle blue)
      const fillLight = new THREE.PointLight(0x0044ff, 15, 8);
      fillLight.position.set(0, -2, 0);
      scene.add(fillLight);

      // Stylized Circular Grid Floor
      const gridMaterial = new THREE.ShaderMaterial({
        transparent: true,
        uniforms: {},
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `
          varying vec2 vUv;
          void main() {
            vec2 c = vUv - 0.5;
            float d = length(c);
            float ring = abs(fract(d * 10.0) - 0.5) * 2.0;
            float radial = abs(fract(atan(c.y, c.x) / 6.283 * 24.0) - 0.5) * 2.0;
            float alpha = smoothstep(0.48, 0.5, max(ring, radial)) * 0.3;
            alpha *= smoothstep(0.5, 0.3, d); // Fade at edges
            gl_FragColor = vec4(0.2, 0.8, 1.0, alpha);
          }
        `
      });
      const floorGeom = new THREE.PlaneGeometry(20, 20);
      const floor = new THREE.Mesh(floorGeom, gridMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -1.5;
      scene.add(floor);

      particleGroup = new THREE.Group();
      scene.add(particleGroup);

      modelGroup = new THREE.Group();
      modelGroup.visible = true; // Default to Model mode
      scene.add(modelGroup);

      geometry = new THREE.BufferGeometry();
      positions = new Float32Array(PARTICLE_COUNT * 3);
      velocities = new Float32Array(PARTICLE_COUNT * 3);
      life = new Float32Array(PARTICLE_COUNT);

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        positions[i3] = (Math.random() - 0.5) * 4;
        positions[i3 + 1] = (Math.random() - 0.5) * 4;
        positions[i3 + 2] = (Math.random() - 0.5) * 4;
        velocities[i3] = velocities[i3 + 1] = velocities[i3 + 2] = 0;
        life[i] = Math.random() * 1;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      material = new THREE.PointsMaterial({
        size: 0.06,
        map: makeCircleTexture(),
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        color: new THREE.Color(colorPicker.value)
      });

      particlePoints = new THREE.Points(geometry, material);
      particlePoints.visible = false; // Default to Model mode
      particleGroup.add(particlePoints);

      window.addEventListener('resize', onResize);
    }

    function onResize() {
      const w = appEl.clientWidth, h = appEl.clientHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    // Shape generators (target point clouds)
    function buildHeartPoints(count = 2500) {
      const pts = [];
      for (let i = 0; i < count; i++) {
        const t = Math.random() * Math.PI * 2;
        // Classic 2D parametric heart (scaled to ~unit)
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
        const nx = x / 18; // normalize roughly into [-1.2..1.2]
        const ny = (y / 18) * 1.1;
        const nz = (Math.random() - 0.5) * 0.6; // give some depth
        pts.push(new THREE.Vector3(nx, ny, nz));
      }
      return pts;
    }

    function buildFlowerPoints(count = 2500, k = 5) {
      const pts = [];
      for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const r = Math.cos(k * theta);
        const nx = r * Math.cos(theta);
        const ny = r * Math.sin(theta);
        const nz = (Math.random() - 0.5) * 0.8;
        pts.push(new THREE.Vector3(nx, ny, nz));
      }
      return pts;
    }

    function buildSaturnPoints(count = 2500) {
      const pts = [];
      const ringCount = Math.floor(count * 0.6);
      const planetCount = count - ringCount;
      // Ring (tilted)
      const tilt = 0.5; // radians
      for (let i = 0; i < ringCount; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = 1.4 + (Math.random() - 0.5) * 0.15; // thin ring
        let x = r * Math.cos(a);
        let y = (Math.random() - 0.5) * 0.05;
        let z = r * Math.sin(a);
        // tilt around X
        const ty = y * Math.cos(tilt) - z * Math.sin(tilt);
        const tz = y * Math.sin(tilt) + z * Math.cos(tilt);
        pts.push(new THREE.Vector3(x, ty, tz));
      }
      // Planet (sphere shell)
      for (let i = 0; i < planetCount; i++) {
        const u = Math.random();
        const v = Math.random();
        const phi = 2 * Math.PI * u;
        const cosTheta = 2 * v - 1;
        const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
        const r = 0.8 + (Math.random() - 0.5) * 0.05;
        const x = r * sinTheta * Math.cos(phi);
        const y = r * sinTheta * Math.sin(phi);
        const z = r * cosTheta;
        pts.push(new THREE.Vector3(x, y, z));
      }
      return pts;
    }

    function buildAllShapes() {
      targetShapes.hearts = buildHeartPoints();
      targetShapes.flowers = buildFlowerPoints();
      targetShapes.saturn = buildSaturnPoints();
    }

    // Gesture mapping
    function getPrimaryHandIndex(hands) {
      // Prefer Right hand for rotation if available
      if (!hands || hands.length === 0) return 0;
      if (hands.length === 1) return 0;
      // mediapipe Hands (classic) does not pass handedness labels alongside landmarks easily here
      // We'll choose the hand whose index finger x is greater (assume right hand on mirrored user camera)
      const i0 = hands[0][8];
      const i1 = hands[1][8];
      return (i0.x > i1.x) ? 0 : 1;
    }

    function computeOpenness(hand) {
      // Use average distance from fingertips to palm center, normalized by palm size
      if (!hand) return 0;
      const wrist = hand[0];
      const mcpIdx = [5, 9, 13, 17];
      const tips = [8, 12, 16, 20];
      // Palm center approx as mean of MCPs and wrist
      let cx = wrist.x, cy = wrist.y;
      for (const id of mcpIdx) { cx += hand[id].x; cy += hand[id].y; }
      cx /= (mcpIdx.length + 1); cy /= (mcpIdx.length + 1);
      // Palm size: distance wrist to middle MCP
      const mid = hand[9];
      const palmSize = Math.hypot(mid.x - wrist.x, mid.y - wrist.y) + 1e-6;
      let avg = 0;
      for (const id of tips) {
        const p = hand[id];
        avg += Math.hypot(p.x - cx, p.y - cy) / palmSize;
      }
      avg /= tips.length;
      // Map roughly 0.3 (closed) .. 1.0 (open)
      return clamp((avg - 0.3) / (0.7), 0, 1);
    }

    // Physics State
    let targetScale = 1.2;
    let lastStableScale = 1.2;
    let grabStartTime = 0;

    let targetExpansion = 0.2;
    // Rotation velocity is already global `rotationVel`
    // Rotation velocity is already global `rotationVel`

    // Translation
    let targetPos = { x: 0, y: 0, z: 0 }; // World units (approx)
    let lastPinchCenter = null;
    let lastPinchAngle = null;

    function isPinched(hand) {
      if (!hand) return false;
      const thumb = hand[4];
      const index = hand[8];
      const d = Math.hypot(thumb.x - index.x, thumb.y - index.y);
      return d < 0.05; // Threshold for pinch
    }

    function updateGestureControls(results) {
      const hands = results.multiHandLandmarks || [];
      haveHands = hands.length;
      const now = performance.now();

      // Debug draw (null-safe)
      if (debugToggle && debugToggle.checked) {
        debugCanvas.classList.remove('hidden');
        drawCtx.save();
        drawCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
        if (debugCanvas.width === 0) {
          debugCanvas.width = 640; debugCanvas.height = 360;
        }
        drawCtx.drawImage(results.image, 0, 0, debugCanvas.width, debugCanvas.height);
        for (const hand of hands) {
          drawCtx.fillStyle = 'rgba(0,255,180,0.8)';
          for (const p of hand) {
            drawCtx.beginPath();
            drawCtx.arc(p.x * debugCanvas.width, p.y * debugCanvas.height, 2, 0, Math.PI * 2);
            drawCtx.fill();
          }
        }
        drawCtx.restore();
      } else if (debugCanvas) {
        debugCanvas.classList.add('hidden');
      }

      const idx = getPrimaryHandIndex(hands);
      const primaryHand = hands[idx];
      const secondaryHand = hands.length > 1 ? hands[(idx + 1) % 2] : null;

      const pinchedPrimary = isPinched(primaryHand);
      const pinchedSecondary = isPinched(secondaryHand);

      // --- LOGIC ---
      let actionState = "IDLE";

      // Safety: Reset tracking if conditions met
      if (!primaryHand || !pinchedPrimary) lastIndexTip = null;
      if (hands.length < 2 || !pinchedPrimary || !pinchedSecondary) {
        lastPinchCenter = null;
        lastPinchAngle = null;
      }

      // 1. TWO HANDS PINCHED: Move + Scale + Rotate Z
      if (hands.length >= 2 && pinchedPrimary && pinchedSecondary) {
        grabStartTime = 0;
        actionState = "DUAL PINCH (Move/Scale/Spin)";

        // STABLE HAND ORDERING: Always use left-most hand as A, right-most as B
        // This prevents frame-to-frame swapping that causes jumps.
        const handA = primaryHand[8].x < secondaryHand[8].x ? primaryHand : secondaryHand;
        const handB = primaryHand[8].x < secondaryHand[8].x ? secondaryHand : primaryHand;
        const iA = handA[8];
        const iB = handB[8];

        // A. SCALE (Distance)
        // Lower Sensitivity: Map larger physical distance to scale range
        const dist = Math.hypot(iA.x - iB.x, iA.y - iB.y);
        let s = (clamp(dist, 0.05, 0.8) - 0.05) / 0.75;
        s = Math.pow(s, 1.2) * 5.0;
        s = clamp(s, 0.1, 5.0);
        if (Math.abs(s - lastStableScale) / lastStableScale > 0.05) {
          targetScale = s;
          lastStableScale = s;
        }

        // B. TRANSLATION (Midpoint) - Increased smoothing (0.5)
        const midX = (iA.x + iB.x) / 2;
        const midY = (iA.y + iB.y) / 2;
        const currentCenter = { x: midX, y: midY };

        if (lastPinchCenter) {
          const dx = (currentCenter.x - lastPinchCenter.x) * 12.0;
          const dy = (currentCenter.y - lastPinchCenter.y) * 12.0;
          // Position Smooth: 0.2 (Golden Ratio)
          targetPos.x += dx * 0.2;
          targetPos.y -= dy * 0.2;
        }
        lastPinchCenter = currentCenter;

        // C. ROTATION Z (Angle) - Increased smoothing (0.5)
        const angle = Math.atan2(iB.y - iA.y, iB.x - iA.x);
        if (lastPinchAngle !== null) {
          let dAngle = angle - lastPinchAngle;
          // Wrap
          if (dAngle > Math.PI) dAngle -= Math.PI * 2;
          if (dAngle < -Math.PI) dAngle += Math.PI * 2;

          // Safety: Hand Swap Protection
          if (Math.abs(dAngle) > 2.0) {
            dAngle = 0;
          } else {
            // Anti-Hunting: Lowered threshold
            if (Math.abs(dAngle) < 0.005) dAngle = 0;
          }

          // Rotation Smooth: 0.3 (Golden Ratio), Sensitivity 4.0
          rotationVel.z = lerp(rotationVel.z, -dAngle * 4.0, 0.3);
        }
        lastPinchAngle = angle;

      }
      // 2. SINGLE HAND PINCH: Rotate X/Y (Trackball)
      else if (primaryHand && pinchedPrimary && (!secondaryHand || !pinchedSecondary)) {
        if (grabStartTime === 0) {
          grabStartTime = now;
        } else if (now - grabStartTime > 100) {
          actionState = "GRABBED (Rotating)";
          const tip = primaryHand[8];

          // XY Rotation
          if (lastIndexTip) {
            const dx = tip.x - lastIndexTip.x;
            const dy = tip.y - lastIndexTip.y;
            if (Math.hypot(dx, dy) > 0.001) {
              rotationVel.y = lerp(rotationVel.y, -dx * 3.5, 0.3);
              rotationVel.x = lerp(rotationVel.x, -dy * 3.5, 0.3);
            } else {
              rotationVel.y = lerp(rotationVel.y, 0, 0.1);
              rotationVel.x = lerp(rotationVel.x, 0, 0.1);
            }
          }
          lastIndexTip = { x: tip.x, y: tip.y };
        }
      }
      else {
        // Idle / Inertia
        grabStartTime = 0;
        lastIndexTip = null;
        if (primaryHand) delete primaryHand.lastAngle; // This was for single-hand Z-rotation, no longer needed here

        // Inertia
        rotationVel.x *= 0.92;
        rotationVel.y *= 0.92;
        rotationVel.z *= 0.92;
      }

      // 3. EXPLOSION: Two Hands Open (Not Pinched)
      // "Position Smooth 0.2"
      if (hands.length >= 2 && !pinchedPrimary && !pinchedSecondary) {
        grabStartTime = 0;
        actionState = "OPEN (Expanding)";
        const getPalmCenter = (h) => ({ x: (h[0].x + h[9].x) * 0.5, y: (h[0].y + h[9].y) * 0.5 });
        const p1 = getPalmCenter(primaryHand);
        const p2 = getPalmCenter(secondaryHand);
        const d = Math.hypot(p1.x - p2.x, p1.y - p2.y);

        // "Offset Correction": subtract 0.2
        let val = Math.max(0, d - 0.2);
        // Remap the remaining range (e.g. 0.0..0.4) to 0..1
        let te = val / 0.3; // 0.3 range (0.2 to 0.5)
        te = Math.pow(te, 1.2) * 1.05;
        targetExpansion = clamp(te, 0.0, 1.0);
      } else {
        // Return to assembled state slowly if no input
        if (hands.length < 2) targetExpansion = 0;
      }

      // Apply Smoothing (Golden Ratio: 0.2)
      globalScale = lerp(globalScale, targetScale, 0.2);
      expansion = lerp(expansion, targetExpansion, 0.2);

      const handMsg = hands.length ? `Hands: ${hands.length} | State: ${actionState} | Scale: ${globalScale.toFixed(2)}` : 'Show hands! Pinch Two=Move/Scale/Spin, Pinch One=Rotate, Open=Explode';
      statusEl.textContent = handMsg;
    }

    // Particle system update
    function updateParticles(dt) {
      // Rotate group via gesture
      particleGroup.rotation.y += rotationVel.y * dt * 60;
      particleGroup.rotation.x += rotationVel.x * dt * 60;
      particleGroup.rotation.z += rotationVel.z * dt * 60;
      // No damping needed, velocity is 0 if not interacting
      // rotationVel.x *= ROT_DAMP; ...

      const positionsAttr = geometry.getAttribute('position');
      const count = PARTICLE_COUNT;

      if (currentTemplate === 'fireworks') {
        // Fireworks mode: integrate velocities with damping and gravity
        const gravity = -0.4;
        const damp = 0.995;
        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          velocities[i3 + 1] += gravity * dt; // gravity on y
          velocities[i3] *= damp; velocities[i3 + 1] *= damp; velocities[i3 + 2] *= damp;
          positions[i3] += velocities[i3] * dt;
          positions[i3 + 1] += velocities[i3 + 1] * dt;
          positions[i3 + 2] += velocities[i3 + 2] * dt;
          life[i] -= dt * 0.25;
          if (life[i] <= 0) {
            // Respawn if expansion high, otherwise keep subtle
            const spread = 1.0 + expansion * 2.0;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const speed = (0.8 + Math.random() * 0.6) * (1.0 + expansion * 2.0);
            const sx = Math.sin(phi) * Math.cos(theta);
            const sy = Math.cos(phi);
            const sz = Math.sin(phi) * Math.sin(theta);
            positions[i3] = 0; positions[i3 + 1] = 0; positions[i3 + 2] = 0;
            velocities[i3] = sx * speed * spread;
            velocities[i3 + 1] = sy * speed * spread;
            velocities[i3 + 2] = sz * speed * spread;
            life[i] = 1.0 + Math.random() * 0.5;
          }
        }
        positionsAttr.needsUpdate = true;
        return;
      }

      // Target-following mode
      const follow = 2.5; // attraction strength
      const outward = expansion * 1.2; // outward push
      const damp = 0.88;

      const target = targetShapes[currentTemplate];
      const tCount = target.length;
      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const tp = target[i % tCount];
        const tx = tp.x * globalScale;
        const ty = tp.y * globalScale;
        const tz = tp.z * globalScale;

        const px = positions[i3];
        const py = positions[i3 + 1];
        const pz = positions[i3 + 2];

        // Attraction to target point
        const ax = (tx - px) * follow * dt;
        const ay = (ty - py) * follow * dt;
        const az = (tz - pz) * follow * dt;

        // Outward push from center for openness
        const len = Math.hypot(px, py, pz) + 1e-6;
        const ox = (px / len) * outward * dt;
        const oy = (py / len) * outward * dt;
        const oz = (pz / len) * outward * dt;

        velocities[i3] = (velocities[i3] + ax + ox) * damp;
        velocities[i3 + 1] = (velocities[i3 + 1] + ay + oy) * damp;
        velocities[i3 + 2] = (velocities[i3 + 2] + az + oz) * damp;

        positions[i3] += velocities[i3] * dt;
        positions[i3 + 1] += velocities[i3 + 1] * dt;
        positions[i3 + 2] += velocities[i3 + 2] * dt;
      }
      positionsAttr.needsUpdate = true;
    }

    // Model update (explode/implode)
    function updateModel(dt) {
      if (!modelGroup || modelParts.length === 0) return;

      // Rotate via gesture
      modelGroup.rotation.y += rotationVel.y * dt * 60;
      modelGroup.rotation.x += rotationVel.x * dt * 60;
      modelGroup.rotation.z += rotationVel.z * dt * 60;
      // No damping needed

      // Translate via gesture (Two Hand Pinch)
      // Snappy: Direct assignment or Lerp 1.0 (approximated for safety)
      modelGroup.position.lerp(new THREE.Vector3(targetPos.x, targetPos.y, targetPos.z), 0.8);

      // Scale via index distance
      const s = modelNormScale * clamp(globalScale, 0.2, 5);
      modelGroup.scale.set(s, s, s);

      // Separation via openness
      const sep = expansion * modelRadius * 1.6; // tuned range
      for (const part of modelParts) {
        part.obj.position.copy(part.base).addScaledVector(part.dir, sep);
      }
    }

    function triggerFireworksBurst() {
      // Reset all particles to origin with explosive velocities
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        positions[i3] = positions[i3 + 1] = positions[i3 + 2] = 0;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const speed = 1.2 + Math.random() * 1.8;
        velocities[i3] = Math.sin(phi) * Math.cos(theta) * speed;
        velocities[i3 + 1] = Math.cos(phi) * speed;
        velocities[i3 + 2] = Math.sin(phi) * Math.sin(theta) * speed;
        life[i] = 0.7 + Math.random() * 0.8;
      }
      geometry.getAttribute('position').needsUpdate = true;
      fwCooldown = 0.3; // minimum time between bursts
    }

    // Build model from loaded GLTF/GLB
    function loadModelFile(file) {
      if (!file) return;
      try {
        const url = URL.createObjectURL(file);
        loadModelUrl(url, true);
      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Model load failed.';
      }
    }

    function loadModelUrl(url, revokeAfterLoad = false) {
      try {
        const loader = new GLTFLoader();
        statusEl.textContent = 'Loading model…';
        loader.load(url, (gltf) => {
          if (revokeAfterLoad) URL.revokeObjectURL(url);
          buildModelFromScene(gltf.scene || gltf.scenes?.[0]);
          activeMode = 'model';
          modeSelect.value = 'model';
          particlePoints.visible = false;
          modelGroup.visible = true;
          modelControls.classList.remove('hidden');
          statusEl.textContent = 'Model loaded. 手を開く=分解/閉じる=集合, 人差し指の距離=スケール, 右の人差し指の動き=回転';
        }, undefined, (err) => {
          console.error(err);
          if (revokeAfterLoad) URL.revokeObjectURL(url);
          statusEl.textContent = 'Model load failed.';
        });
      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Model load failed.';
      }
    }

    function buildModelFromScene(root) {
      if (!root) { statusEl.textContent = 'Invalid model scene.'; return; }

      // Clear previous
      while (modelGroup.children.length) modelGroup.remove(modelGroup.children[0]);
      modelParts = [];

      // Collect meshes
      const meshes = [];
      root.traverse((o) => { if (o.isMesh) meshes.push(o); });
      if (meshes.length === 0) { statusEl.textContent = 'No meshes found in model.'; return; }

      // Flatten: keep world transforms, reparent to modelGroup
      for (const m of meshes) {
        m.updateWorldMatrix(true, true);
        const world = m.matrixWorld.clone();
        modelGroup.add(m); // reparent (removes from old parent)
        world.decompose(m.position, m.quaternion, m.scale);
        m.updateMatrix();
        m.updateMatrixWorld(true);
      }

      // Center the group at origin
      modelGroup.updateMatrixWorld(true);
      const box = new THREE.Box3().setFromObject(modelGroup);
      const center = box.getCenter(new THREE.Vector3());
      for (const m of meshes) { m.position.sub(center); m.updateMatrixWorld(true); }

      // Compute radius and normalization scale
      const sphere = new THREE.Sphere();
      new THREE.Box3().setFromObject(modelGroup).getBoundingSphere(sphere);
      modelRadius = sphere.radius || 1;
      modelNormScale = 1.2 / modelRadius;

      // Prepare parts data (direction from group origin to part center)
      for (const m of meshes) {
        const bb = new THREE.Box3().setFromObject(m);
        const cWorld = bb.getCenter(new THREE.Vector3());
        const cLocal = modelGroup.worldToLocal(cWorld.clone());
        let dir = cLocal.clone();
        if (dir.length() < 1e-3) {
          // generate stable pseudo-random direction for near-center parts
          const name = m.name || 'mesh';
          let h = 0; for (let i = 0; i < name.length; i++) h = ((h << 5) - h) + name.charCodeAt(i) | 0;
          const rand = (n) => ((Math.sin(h + n) * 43758.5453) % 1) - 0.5;
          dir.set(rand(1), rand(2), rand(3));
        }
        dir.normalize();
        modelParts.push({ obj: m, base: m.position.clone(), dir });
      }

      modelGroup.visible = (activeMode === 'model');
    }

    // MediaPipe Hands setup
    async function initHands() {
      try {
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.6,
          minTrackingConfidence: 0.6
        });
        hands.onResults(updateGestureControls);

        const camera = new Camera(videoEl, {
          onFrame: async () => {
            await hands.send({ image: videoEl });
          },
          width: 640,
          height: 360
        });
        await camera.start();
        statusEl.textContent = 'Camera ready. Show both hands. 人差し指の距離=サイズ / 右手の人差し指の動き=回転 / 手の開き=拡散・分解';
      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Camera failed or permission denied. You can still enjoy an auto demo.';
        // Fallback: simple auto rotation
        setInterval(() => {
          rotationVel.y = lerp(rotationVel.y, 0.003, 0.1);
        }, 1000);
      }
    }

    // UI bindings (null-safe)
    if (templateSelect) {
      templateSelect.addEventListener('change', (e) => {
        currentTemplate = e.target.value;
        if (currentTemplate === 'fireworks') {
          triggerFireworksBurst();
        }
        if (statusEl) statusEl.textContent = `Template: ${currentTemplate}`;
      });
    }

    if (colorPicker) {
      colorPicker.addEventListener('input', (e) => {
        const col = new THREE.Color(e.target.value);
        if (material) material.color.copy(col);
      });
    }

    if (modeSelect) {
      modeSelect.addEventListener('change', (e) => {
        activeMode = e.target.value;
        const isModel = activeMode === 'model';
        if (particlePoints) particlePoints.visible = !isModel;
        if (modelGroup) modelGroup.visible = isModel && modelParts.length > 0;
        if (modelControls) modelControls.classList.toggle('hidden', !isModel);
        if (statusEl) statusEl.textContent = isModel ? 'Model mode. Load a GLTF/GLB file to begin.' : `Particles mode: ${currentTemplate}`;
      });
    }

    if (modelFileInput) {
      modelFileInput.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (file) loadModelFile(file);
      });
    }

    // Main loop
    let lastTime = performance.now();
    function animate() {
      const now = performance.now();
      let dt = (now - lastTime) / 1000;
      dt = Math.min(dt, 0.05); // clamp to keep stability
      lastTime = now;

      if (activeMode === 'particles') {
        if (currentTemplate === 'fireworks') {
          if (fwCooldown > 0) fwCooldown -= dt;
          // Trigger more bursts proportional to openness
          if (expansion > 0.6 && fwCooldown <= 0) {
            triggerFireworksBurst();
          }
        }
        updateParticles(dt);
      } else {
        updateModel(dt);
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Initialize
    (function start() {
      initThree();
      buildAllShapes();
      initHands();

      // Auto-load user model if provided
      const params = new URLSearchParams(location.search);
      const modelParam = params.get('model');
      if (modelParam) {
        loadModelUrl(modelParam);
      } else {
        // Try to fetch model.glb next to index.html
        fetch('model.glb', { method: 'HEAD' }).then((res) => {
          if (res.ok) {
            loadModelUrl('model.glb');
          }
        }).catch(() => { });
      }

      animate();
    })();
  </script>
</body>

</html>